module GamePlaying(
	input clk,                    //50MHz
	input reset,                  //高电平停止滚屏
	input [6:0] h_ascii, 	      //30*70的横坐标
	input [9:0] v_addr,           //480*630像素点的纵坐标
	input [7:0] scancode,	      //键盘输入字符的扫描码
	input GameMode,               //游戏模式（无尽/生存）
	input [3:0] GameLevel,        //游戏难度值
	input GameStart,              //游戏开始
	input GameRestart,            //状态重置
	input key_ready,              //有按键松开
	
	output [3:0] v_font,          //16*9字模内的行数
	output [7:0] curASCII,	      //当前需要显示的ASCII
	
	output fail,                  //游戏失败
	output succ,                  //游戏成功
	
	output reg [9:0] target,      //目标分数
	output reg [9:0] speed_freq,  //字符下滑速度
	output [3:0] life_out,        //生命值
	output reg [9:0] score        //游戏分数
	);

	//游戏界面相关屏幕参数
	parameter MAX_COL = 50; //横向50个字符
	parameter MAX_ROW = 31; //纵向31个字符行（多一个是用于产生新的随机字符）
	parameter LINEPIXEL = MAX_ROW * 16; //纵向31*16个像素行
	
	
	//模式、难度值的翻译：
	reg [6:0] num_max; //写入新行时的最大字符数
	reg [3:0] life; //生命值
	reg key_bingo = 0;//是否匹配到输入字符
always @(*) begin
	target = 599;
	if(!GameMode) begin //无尽模式
		case(GameLevel) //分别为：每行最大字符数、移动频率（以每个像素点为单位）
		4'h1:    begin num_max = rand_num & 4'b0011; speed_freq = 20;  target = 29;  end
		4'h2:    begin num_max = rand_num & 4'b0011; speed_freq = 40;  target = 69;  end
		4'h3:    begin num_max = rand_num & 4'b0011; speed_freq = 60;  target = 99;  end		
	
		default: begin num_max = rand_num & 4'b0011; speed_freq = 100;               end
		endcase
	end
	else begin //闯关模式
		case(GameLevel) //分别为：每行最大字符数、移动频率（以每个像素点为单位）、目标分数
		4'h1:    begin num_max = rand_num & 4'b0011; speed_freq = 20;  target = 29;  end
		4'h2:    begin num_max = rand_num & 4'b0011; speed_freq = 25;  target = 39;  end
		4'h3:    begin num_max = rand_num & 4'b0011; speed_freq = 35;  target = 49;  end
		4'h4:    begin num_max = rand_num & 4'b0011; speed_freq = 50;  target = 59;  end
		4'h5:    begin num_max = rand_num & 4'b0011; speed_freq = 80;  target = 100; end
		4'h6:    begin num_max = rand_num & 4'b0011; speed_freq = 100; target = 120; end
		4'h7:    begin num_max = rand_num & 4'b0011; speed_freq = 110; target = 130; end
		4'h8:    begin num_max = rand_num & 4'b0011; speed_freq = 120; target = 140; end
		
		default: begin num_max = rand_num & 4'b0011; speed_freq = 25;  target = 29;  end
		endcase	
	end
end

	assign fail = ((!GameMode) ? (0) : (life == 0)) || keyASCII == 8'h08; //无尽模式下生命值无限
	assign succ = (score >= target) || GameRestart; //可通过按钮 手动“胜利”
	assign life_out = (life <= 9) ? (life) : (0); //控制只显示 0~9 的生命值
	
	
	
	
	
	
	wire [4:0] v_ascii;
	wire [9:0] Now_v_addr;
	//计算带上偏移量后的v_addr：
	assign Now_v_addr = LINEPIXEL + v_addr - bias; //偏移后的像素点纵坐标
	//利用Now_v_addr计算访问RAM的位置以及字符地址:
	assign v_ascii = (Now_v_addr % LINEPIXEL) >> 4; //30*70的纵坐标
	assign raddr = v_ascii * MAX_COL + h_ascii; //31*50RAM的读地址
	assign v_font = Now_v_addr & 4'b1111; //16*9字模内的行数
 	
	//即将进入屏幕的那个字符行：
	wire [4:0] NowLine;
	assign NowLine = (LINEPIXEL - bias) >> 4; //再%LINEPIXEL？
	
	//1号RAM显存
	//读相关
	reg [7:0] newASCII;      //准备写入31*50RAM的数据值
	wire [10:0] raddr;       //31*50RAM的读地址
	wire [10:0] waddr;       //31*50RAM的写地址
	reg wren;	             //写使能
GameASCII my_GameASCII1(
	.clock(clk),
	.data(newASCII),
	.rdaddress(raddr),
	.wraddress(waddr),
	.wren(wren),
	.q(curASCII)
	);
	
	
	//2号RAM显存，写操作与1号完全一致，而读操作是独立的，目的是增加一个自由读出的端口
	wire [10:0] raddr2;      //31*50RAM的读地址
	wire [7:0] curASCII2;    //从31*50RAM读取的数据值
GameASCII my_GameASCII2(
	.clock(clk),
	.data(newASCII),
	.rdaddress(raddr2),
	.wraddress(waddr),
	.wren(wren),
	.q(curASCII2)
	);
	
initial
begin
	life = 9;
	score = 0;
	Stage = 0;
	bias = 0;
	newASCII = 0;
	wren = 0;
	rand_addr = 0;
	clean = 0;
	num_max = 1;
	speed_freq = 50;
	clean_count = 0;
	GameRestart2 = 0;
	key_ready2 = 0;
end
	
	
//Clock for Bias changing
	wire clk_bias;
clk_speed clk_speed0(
	.clk_freq(speed_freq),
	.clkin(clk),
	.rst(reset),
	.clken(~reset),
	.clkout(clk_bias)
);	
	//Change Bias
	reg [8:0] bias; //偏移量
always @(posedge clk_bias)
begin
	if(bias < LINEPIXEL)
		bias = bias + 1;
	else
		bias = 0;
end

	//用于产生新的随机行
	wire [3:0] newLine;
	assign newLine = bias[3:0];
	reg [3:0] newLine2;
	//Game_Over相关
	reg GameRestart2;
	reg key_ready2;
	
	//键盘按下，KEYCLEAN状态
	reg [7:0] keyASCII; //将要清除的字符的ASCII码
	reg clean; //字符清除状态
	reg [10:0] clean_addr; //31*50清除字符所在地址
	reg [31:0] clean_count; //处于GO_CLEAN的时钟周期数
	reg life_deduct; //为真时表示错过了字符，应当life减少
	
	
	//生成随机数
	wire [3:0] rand_num;
	wire [6:0] rand_col;
	wire [7:0] rand_ASCII;
	reg [9:0] rand_addr; //读随机表的地址
	reg [6:0] rand_count;//记录对新行随机写入的次数
	
	randASCII my_randASCII(rand_addr, clk, rand_ASCII);
	rand8Bits my_rand8Bits(rand_addr, clk, rand_num);
	wire [6:0] rand_col64;
	rand64 my_rand64(rand_addr, clk, rand_col64);
	assign rand_col = (rand_col64) % MAX_COL;
	
	reg [6:0] col_index;
	assign waddr = (Stage == KEYCLEAN || Stage == RESETGAME) ? (clean_addr) : (NowLine * MAX_COL + col_index); 
	//KEYCLEAN状态下，利用上一次读出的数据，决定要不要写0，所以应该和读的上一次的地址保持一致
	assign raddr2 = (Stage == KEYCLEAN || Stage == RESETGAME) ? (clean_addr) : (waddr);

	//【核心】控制读写RAM的状态机
	//状态机的所有运行模式  
	reg [3:0] Stage; 
	localparam WAITING = 0;  			   //待机
	localparam CREATNEW_CLEAN = 1;  	   //准备产生新行，先清空一行
	localparam CREATNEW = 2;				//在清空的行中，随机写入值
	localparam KEYCLEAN = 3;				//接受的键盘键松开的信号，消字符
	localparam RESETGAME = 4;				//将IP核RAM的所有内容清为0
	
//不断产生新的行的状态机 （带2的变量都是备份上一时钟沿时的值）		
always @(negedge clk)
begin
	
	//设置clean_count，对处于clean状态的时钟沿个数计数
	//目的是避免长时间陷入clean的死循环，导致状态机失效
	if(clean) begin
		clean_count = clean_count + 1;
	end
	
	if(clean_count >= 10 * MAX_COL * MAX_ROW) begin
		clean = 0;
		clean_count = 0;
	end
	
	//现在版本：
	//key_ready是来自键盘模块的信号，此处说明有按键松开
	if((!clean) && (!key_ready2) && (key_ready)) begin 
		scancode2ascii(1, 0, scancode, keyASCII);//将扫描码翻译成ASCII码
		clean = 1;
	end
	
//	//之前版本：有识别不出来的情况，故舍去
//	//scancode是来自键盘模块的扫描码，此处说明有按键松开
//	if((!clean) && (scancode2 != scancode) && (scancode2 == 8'hF0)) begin 
//		scancode2ascii(1, 0, scancode, keyASCII);//将扫描码翻译成ASCII码
//		clean = 1;
//	end
	
case(Stage) //此处每个状态进入下一个状态前，都会预先准备好一次下个的状态的参量

//待机
WAITING: begin

	//保持本状态
	clean_addr = 0;
	rand_count = 0;
	wren = 0;
	if(newLine2 != newLine && newLine == 4'h1) begin //准备清空新行
		//预先清一次
		newASCII = 0;
		col_index = 0;
		life_deduct = 0;
		wren = 1;
		Stage = CREATNEW_CLEAN;
	end
	
	if(clean && keyASCII != 0) begin //键盘按下且松开(且对应ascii码不是0)
		Stage = KEYCLEAN;
		wren = 0;
		clean_addr = 0;
		clean = 0;
	end
	
	//如果游戏未开始 或者 GameRestart按下(0->1)，则需要保持重置状态
	if(!GameStart || (GameRestart2 == 0 && GameRestart == 1)) begin 
		life = 9;
		score = 0;
		Stage = RESETGAME;
		newASCII = 0;
		clean_addr = 0;
		wren = 1;
		clean = 0;
	end
	
end

//先清空 即将移入屏幕的那一行
CREATNEW_CLEAN: begin 
	if(curASCII2 != 0) begin //清空的值不是0  说明 漏掉字符没消除，生命值-1
		life_deduct = 1;
	end
	
	if(col_index == MAX_COL - 1) begin //清空结束，预先准备好随机写入一次需要的参数值
		if(life_deduct) begin
			life = life - 1;
			life_deduct = 0;
		end
		Stage = CREATNEW;
		rand_count = 0;
		col_index = rand_col;
		newASCII = rand_ASCII;
		if(rand_count >= num_max) begin //控制随机写入的个数
			col_index = 0;
			wren = 0;
			Stage = WAITING;
		end
		rand_addr = rand_addr + 1;
	end
	
	else begin //保持本状态(继续清空本行)
		col_index = col_index + 1;
	end
end

//在清空的行中，随机写入字符
CREATNEW: begin
	rand_count = rand_count + 1;
	if(rand_count >= num_max) begin //控制随机写入的个数
		col_index = 0;
		wren = 0;
		rand_count = 0;
		Stage = WAITING;
	end
	else begin //保持本状态
		col_index = rand_col;
		newASCII = rand_ASCII;	
		rand_addr = rand_addr + 1;
	end
end

//接受到键盘键松开的信号，消字符
KEYCLEAN: begin
	clean = 0;
	if(wren == 0 && curASCII2 == keyASCII) begin 
	//访问IP核发现了一个匹配的字符 开启写使能 保持地址不变，在下一个时钟沿写入0 即清除字符
		wren = 1;
		newASCII = 0;
		score = score + 1;
		key_bingo = 1;
	end
	else begin//否则，地址加一，继续访问IP核
		wren = 0;
		clean_addr = clean_addr + 1;
	end
	
	if(clean_addr >= MAX_COL * MAX_ROW) begin
	//访问地址达到上限 即可跳出本状态
	if(key_bingo == 1)
		key_bingo = 0;
	else
		life = life - 1;
		Stage = WAITING;
		wren = 0;
		clean_addr = 0;
		clean = 0;
		clean_count = 0;
	end
end

//重置游戏：将IP核RAM的所有内容清为0
RESETGAME: begin
	clean_addr = clean_addr + 1;
	if(clean_addr >= MAX_COL * MAX_ROW) begin
		Stage = WAITING;
		wren = 0;
		clean_addr = 0;
	end
end

//默认状态：
default: begin 
   Stage = WAITING; 
	clean = 0; 
	wren = 0; 
	life_deduct = 0;
end

endcase

//更新备份
newLine2 = newLine; 
GameRestart2 = GameRestart;
key_ready2 = key_ready;
end
//状态机结束


task scancode2ascii;//将扫描码翻译成对应的ASCII码，此处使用了大写字母（为了产生大写ASCII，shift置1，假装按下了shift键）
	input shift;
	input capslock;
	input [7:0] scan_code;
	output reg [7:0] ascii_out;
begin
	if(shift)//shift按下
	begin
		case(scan_code)
		8'h01 : ascii_out = 8'h5F;//'_'
		8'h76 : ascii_out = 8'h1b;
		8'h05 : ascii_out = 8'h70;
		8'h06 : ascii_out = 8'h71;
		8'h04 : ascii_out = 8'h72;
		8'h0c : ascii_out = 8'h73;
		8'h03 : ascii_out = 8'h74;
		8'h0b : ascii_out = 8'h75;
		8'h83 : ascii_out = 8'h76;
		8'h0a : ascii_out = 8'h77;
		//8'h01 : ascii_out = 8'h78;
		8'h09 : ascii_out = 8'h79;
		8'h78 : ascii_out = 8'h7a;
		8'h07 : ascii_out = 8'h7b;
		8'h0e : ascii_out = 8'h7e;
		8'h16 : ascii_out = 8'h21;
		8'h1e : ascii_out = 8'h40;
		8'h26 : ascii_out = 8'h23;
		8'h25 : ascii_out = 8'h24;
		8'h2e : ascii_out = 8'h25;
		8'h36 : ascii_out = 8'h5e;
		8'h3d : ascii_out = 8'h26;
		8'h3e : ascii_out = 8'h2a;
		8'h46 : ascii_out = 8'h28;
		8'h45 : ascii_out = 8'h29;
		8'h4e : ascii_out = 8'h5f;
		8'h55 : ascii_out = 8'h2b;
		8'h5d : ascii_out = 8'h7c;
		8'h66 : ascii_out = 8'h08;
		8'h0d : ascii_out = 8'h09;
		8'h15 : ascii_out = 8'h51;
		8'h1d : ascii_out = 8'h57;
		8'h24 : ascii_out = 8'h45;
		8'h2d : ascii_out = 8'h52;
		8'h2c : ascii_out = 8'h54;
		8'h35 : ascii_out = 8'h59;
		8'h3c : ascii_out = 8'h55;
		8'h43 : ascii_out = 8'h49;
		8'h44 : ascii_out = 8'h4f;
		8'h4d : ascii_out = 8'h50;
		8'h54 : ascii_out = 8'h7b;
		8'h5b : ascii_out = 8'h7d;
		8'h5a : ascii_out = 8'h0d;
		8'h58 : ascii_out = 8'h14;
		8'h1c : ascii_out = 8'h41;
		8'h1b : ascii_out = 8'h53;
		8'h23 : ascii_out = 8'h44;
		8'h2b : ascii_out = 8'h46;
		8'h34 : ascii_out = 8'h47;
		8'h33 : ascii_out = 8'h48;
		8'h3b : ascii_out = 8'h4a;
		8'h42 : ascii_out = 8'h4b;
		8'h4b : ascii_out = 8'h4c;
		8'h4c : ascii_out = 8'h3a;
		8'h52 : ascii_out = 8'h22;
		8'h12 : ascii_out = 8'h10;
		8'h1a : ascii_out = 8'h5a;
		8'h22 : ascii_out = 8'h58;
		8'h21 : ascii_out = 8'h43;
		8'h2a : ascii_out = 8'h56;
		8'h32 : ascii_out = 8'h42;
		8'h31 : ascii_out = 8'h4e;
		8'h3a : ascii_out = 8'h4d;
		8'h41 : ascii_out = 8'h3c;
		8'h49 : ascii_out = 8'h3e;
		8'h4a : ascii_out = 8'h3f;
		8'h59 : ascii_out = 8'h10;
		8'h14 : ascii_out = 8'h11;
		8'h11 : ascii_out = 8'h12;
		8'h29 : ascii_out = 8'h20;
		default : ascii_out = 8'h00;
	endcase
	//shift按下时，大写锁定开启：大写转小写
	if(capslock && ascii_out >= 8'h41 && ascii_out <= 8'h5A)
		ascii_out = ascii_out + 32;
	end
	else//shift未按下
	begin
		case(scan_code)
		8'h01 : ascii_out = 8'h5F;//'_'
		8'h76 : ascii_out = 8'h1b;
		8'h05 : ascii_out = 8'h70;
		8'h06 : ascii_out = 8'h71;
		8'h04 : ascii_out = 8'h72;
		8'h0c : ascii_out = 8'h73;
		8'h03 : ascii_out = 8'h74;
		8'h0b : ascii_out = 8'h75;
		8'h83 : ascii_out = 8'h76;
		8'h0a : ascii_out = 8'h77;
		//8'h01 : ascii_out = 8'h78;
		8'h09 : ascii_out = 8'h79;
		8'h78 : ascii_out = 8'h7a;
		8'h07 : ascii_out = 8'h7b;
		8'h0e : ascii_out = 8'h60;
		8'h16 : ascii_out = 8'h31;
		8'h1e : ascii_out = 8'h32;
		8'h26 : ascii_out = 8'h33;
		8'h25 : ascii_out = 8'h34;
		8'h2e : ascii_out = 8'h35;
		8'h36 : ascii_out = 8'h36;
		8'h3d : ascii_out = 8'h37;
		8'h3e : ascii_out = 8'h38;
		8'h46 : ascii_out = 8'h39;
		8'h45 : ascii_out = 8'h30;
		8'h4e : ascii_out = 8'h2d;
		8'h55 : ascii_out = 8'h3d;
		8'h5d : ascii_out = 8'h5c;
		8'h66 : ascii_out = 8'h08;
		8'h0d : ascii_out = 8'h09;
		8'h15 : ascii_out = 8'h71;
		8'h1d : ascii_out = 8'h77;
		8'h24 : ascii_out = 8'h65;
		8'h2d : ascii_out = 8'h72;
		8'h2c : ascii_out = 8'h74;
		8'h35 : ascii_out = 8'h79;
		8'h3c : ascii_out = 8'h75;
		8'h43 : ascii_out = 8'h69;
		8'h44 : ascii_out = 8'h6f;
		8'h4d : ascii_out = 8'h70;
		8'h54 : ascii_out = 8'h5b;
		8'h5b : ascii_out = 8'h5d;
		8'h5a : ascii_out = 8'h0d;
		8'h58 : ascii_out = 8'h14;
		8'h1c : ascii_out = 8'h61;
		8'h1b : ascii_out = 8'h73;
		8'h23 : ascii_out = 8'h64;
		8'h2b : ascii_out = 8'h66;
		8'h34 : ascii_out = 8'h67;
		8'h33 : ascii_out = 8'h68;
		8'h3b : ascii_out = 8'h6a;
		8'h42 : ascii_out = 8'h6b;
		8'h4b : ascii_out = 8'h6c;
		8'h4c : ascii_out = 8'h3b;
		8'h52 : ascii_out = 8'h27;
		8'h12 : ascii_out = 8'h10;
		8'h1a : ascii_out = 8'h7a;
		8'h22 : ascii_out = 8'h78;
		8'h21 : ascii_out = 8'h63;
		8'h2a : ascii_out = 8'h76;
		8'h32 : ascii_out = 8'h62;
		8'h31 : ascii_out = 8'h6e;
		8'h3a : ascii_out = 8'h6d;
		8'h41 : ascii_out = 8'h2c;
		8'h49 : ascii_out = 8'h2e;
		8'h4a : ascii_out = 8'h2f;
		8'h59 : ascii_out = 8'h10;
		8'h14 : ascii_out = 8'h11;
		8'h11 : ascii_out = 8'h12;
		8'h29 : ascii_out = 8'h20;
		default : ascii_out = 8'h00;
		endcase
		//shift未按下时，大写锁定开启：小写转大写
		if(capslock && ascii_out >= 8'h61 && ascii_out <= 8'h7A)
			ascii_out = ascii_out - 32;
	end
end
endtask


endmodule
